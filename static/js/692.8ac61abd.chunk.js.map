{"version":3,"file":"static/js/692.8ac61abd.chunk.js","mappings":"+LAAO,SAASA,EAAOC,GAAuB,IACvCC,EAAQ,WACZ,SAAAA,EAAYC,EAAMC,GAAgC,IAAdC,EAAMC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAC,MAAIG,EAAAA,EAAAA,GAAA,KAAAP,GAC7CQ,KAAKP,KAAOA,EACZO,KAAKC,YAAc,GACnBD,KAAKL,OAASA,EACdK,KAAKN,iBAAmBA,EAExBM,KAAKE,eAAiB,KACtBF,KAAKG,eAAiB,KACnBR,GAAUA,EAAOO,gBAAkBP,EAAOQ,gBAC5CH,KAAKE,eAAiBP,EAAOO,eAAiBF,KAAKP,KAAKW,KACxDJ,KAAKG,eAAkBH,KAAKP,KAAKW,KAAOT,EAAOO,eAAkBF,KAAKL,OAAOQ,gBAEzEH,KAAKP,MACRO,KAAKE,eAAiBG,EAAYL,KAAKP,KAAKW,KAC5CJ,KAAKM,cAAgBN,KAAKP,KAAKW,KAAKC,IAEpCL,KAAKE,eAAiBG,EACtBL,KAAKG,eAAiB,EAG3B,CAIE,OAJDI,EAAAA,EAAAA,GAAAf,EAAA,EAAAgB,IAAA,eAAAC,MAEA,SAAaC,GACZV,KAAKC,YAAYU,KAAKD,EACvB,KAAClB,CAAA,CAzBW,GA4BVa,EAAY,EAKhB,GAJAd,EAAKqB,MAAMC,SAAQ,SAACpB,GACnBY,GAAaZ,EAAKW,IACnB,IAEIb,EAAKqB,MAAMf,OAAO,GACrB,OAAO,KAER,IACIiB,EAGJ,SAASC,EAAeL,EAAMM,GAC7B,GAAgC,IAA5BN,EAAKT,YAAYJ,OACpB,OAAOmB,EAGP,IAAIC,EAAS1B,EAAK0B,OAAO,IACpBP,EAAKjB,KAGTuB,GAAU,GAAGC,GAAUP,EAAKR,eAAeG,IAAcK,EAAKP,eAF9Da,GAAU,EAAEC,EAKb,IAAK,IAAIC,EAAE,EAAGA,EAAER,EAAKT,YAAYJ,OAAQqB,IACxCF,EAAQD,EAAeL,EAAKT,YAAYiB,GAAIF,GAE7C,OAAOA,CAET,CApBYD,CAsBZ,SAAmBV,GAElB,IAAIc,EAAY,IAAI3B,EAAS,KAAMD,EAAKqB,MAAO,MAM/C,OAJAQ,EAAqBD,GAIdA,CAER,CAjCgBE,GACsB,GACtC,OAAOP,EAiCP,SAASM,EAAqBV,GACQ,IAAjCA,EAAKhB,iBAAiBG,SAGzByB,QAAQC,IAAIb,EAAKjB,MACjBiB,EAAKhB,iBAAiBmB,SAAQ,SAAAW,GAC7B,IAAIC,GAAYC,EAAAA,EAAAA,GAAOhB,EAAKhB,kBACxBiC,EAAQF,EAAaG,WAAU,SAAAnC,GAClC,OAAOA,EAAKoC,OAASL,EAAMK,IAC5B,IACIpC,EAAOgC,EAAaK,OAAOH,EAAM,GAAG,GACpCI,EAAU,IAAIvC,EAASC,EAAMgC,EAAcf,GAC/CA,EAAKsB,aAAaD,GAClBX,EAAqBW,EACtB,IAEF,CAgBD,C","sources":["looter/completion-old.js"],"sourcesContent":["export function coupon(data, withPet = false){\n\tclass TreeNode {\n\t  constructor(item, possibleChildren, parent=null) {\n\t    this.item = item;\n\t    this.descendants = [];\n\t    this.parent = parent;\n\t    this.possibleChildren = possibleChildren\n\n\t    this.newTotalWeight = null\n\t    this.cumulativeRate = null\n\t    if(parent && parent.newTotalWeight && parent.cumulativeRate) {\n\t    \tthis.newTotalWeight = parent.newTotalWeight - this.item.rate\n\t    \tthis.cumulativeRate = (this.item.rate / parent.newTotalWeight) * this.parent.cumulativeRate\n\t    } else {\n\t    \tif (this.item) {\n\t    \t\tthis.newTotalWeight = totalRate - this.item.rate\n\t    \t\tthis.cumlativeRate = this.item.rate/totalRate\n\t    \t} else {\n\t    \t\tthis.newTotalWeight = totalRate\n\t    \t\tthis.cumulativeRate = 1\n\t    \t}\n\t    }\n\t\t}\n\n\t  addDecendant(node){\n\t  \tthis.descendants.push(node)\n\t  }\t\n\t}\n\n\tlet totalRate = 0;\n\tdata.items.forEach((item)=> {\n\t\ttotalRate += item.rate\n\t})\n\t//this if factorial growth and explodes around here\n\tif (data.items.length>10){\n\t\treturn null\n\t}\n\tlet startNode = buildTree(totalRate)\n\tlet rolls = calculateRolls(startNode, 0)\n\treturn rolls\n\n\tfunction calculateRolls(node, total){\n\t\tif (node.descendants.length === 0){\n\t\t\treturn total\n\t\t} else {\n\n\t\t\tlet chance = data.chance/100\n\t\t\tif (!node.item) {\n\t\t\t\ttotal += (1/chance)\n\t\t\t} else {\n\t\t\t\ttotal += (1/(chance * (node.newTotalWeight/totalRate)))* node.cumulativeRate\n\t\t\t}\n\n\t\t\tfor (let i=0; i<node.descendants.length; i++){\n\t\t\t\ttotal = calculateRolls(node.descendants[i], total)\n\t\t\t}\n\t\t\treturn total\n\t\t}\n\t}\n\n\tfunction buildTree(totalRate){\n\n\t\tlet startNode = new TreeNode(null, data.items, null)\n\n\t\trecursiveAddChildren(startNode)\n\n\t\t//recursivePrintTree(startNode, 0)\n\n\t\treturn startNode;\n\n\t}\n\n\tfunction recursiveAddChildren(node){\n\t\tif (node.possibleChildren.length === 0){\n\t\t\treturn \n\t\t} else {\n\t\t\tconsole.log(node.item)\n\t\t\tnode.possibleChildren.forEach(child => {\n\t\t\t\tlet childrenCopy = [...node.possibleChildren]\n\t\t\t\tlet index = childrenCopy.findIndex(item => {\n\t\t\t\t\treturn item.name === child.name\n\t\t\t\t})\n\t\t\t\tlet item = childrenCopy.splice(index,1)[0]\n\t\t\t\tlet newNode = new TreeNode(item, childrenCopy, node)\n\t\t\t\tnode.addDecendant(newNode)\n\t\t\t\trecursiveAddChildren(newNode)\n\t\t\t})\n\t\t}\n\t}\n\n\t// function recursivePrintTree(node, index){\n\t// \tindex += 1\n\t// \tconsole.log('Tree depth: ' + index)\n\t// \tconsole.log('Item:' + JSON.stringify(node.item))\n\t// \tconsole.log('Cumulative rate: ' + node.cumulativeRate, node.newTotalWeight)\n\t// \tif (node.descendants.length === 0){\n\t// \t\treturn\n\t// \t} else {\n\t// \t\tfor (let i=0; i<node.descendants.length; i++){\n\t// \t\t\trecursivePrintTree(node.descendants[i], index)\n\t// \t\t}\n\t// \t}\n\t// }\n\n}\n"],"names":["coupon","data","TreeNode","item","possibleChildren","parent","arguments","length","undefined","_classCallCheck","this","descendants","newTotalWeight","cumulativeRate","rate","totalRate","cumlativeRate","_createClass","key","value","node","push","items","forEach","rolls","calculateRolls","total","chance","i","startNode","recursiveAddChildren","buildTree","console","log","child","childrenCopy","_toConsumableArray","index","findIndex","name","splice","newNode","addDecendant"],"sourceRoot":""}