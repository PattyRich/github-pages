{"version":3,"sources":["looter/completion-old.js"],"names":["coupon","data","TreeNode","item","possibleChildren","parent","this","descendants","newTotalWeight","cumulativeRate","rate","totalRate","cumlativeRate","node","push","items","forEach","length","startNode","buildTree","rolls","calculateRolls","total","chance","i","recursiveAddChildren","console","log","child","childrenCopy","index","findIndex","name","splice","newNode","addDecendant"],"mappings":"6LAAO,SAASA,EAAOC,GAAuB,IACvCC,EADsC,WAE1C,WAAYC,EAAMC,GAAgC,IAAdC,EAAa,uDAAN,KAAM,oBAC/CC,KAAKH,KAAOA,EACZG,KAAKC,YAAc,GACnBD,KAAKD,OAASA,EACdC,KAAKF,iBAAmBA,EAExBE,KAAKE,eAAiB,KACtBF,KAAKG,eAAiB,KACnBJ,GAAUA,EAAOG,gBAAkBH,EAAOI,gBAC5CH,KAAKE,eAAiBH,EAAOG,eAAiBF,KAAKH,KAAKO,KACxDJ,KAAKG,eAAkBH,KAAKH,KAAKO,KAAOL,EAAOG,eAAkBF,KAAKD,OAAOI,gBAEzEH,KAAKH,MACRG,KAAKE,eAAiBG,EAAYL,KAAKH,KAAKO,KAC5CJ,KAAKM,cAAgBN,KAAKH,KAAKO,KAAKC,IAEpCL,KAAKE,eAAiBG,EACtBL,KAAKG,eAAiB,GAnBgB,gDAwB1C,SAAaI,GACZP,KAAKC,YAAYO,KAAKD,OAzBmB,KA6BxCF,EAAY,EAKhB,GAJAV,EAAKc,MAAMC,SAAQ,SAACb,GACnBQ,GAAaR,EAAKO,QAGfT,EAAKc,MAAME,OAAO,GACrB,OAAO,KAER,IAAIC,EAAYC,EAAUR,GACtBS,EAAQC,EAAeH,EAAW,GACtC,OAAOE,EAEP,SAASC,EAAeR,EAAMS,GAC7B,GAAgC,IAA5BT,EAAKN,YAAYU,OACpB,OAAOK,EAGP,IAAIC,EAAStB,EAAKsB,OAAO,IACpBV,EAAKV,KAGTmB,GAAU,GAAGC,GAAUV,EAAKL,eAAeG,IAAcE,EAAKJ,eAF9Da,GAAU,EAAEC,EAKb,IAAK,IAAIC,EAAE,EAAGA,EAAEX,EAAKN,YAAYU,OAAQO,IACxCF,EAAQD,EAAeR,EAAKN,YAAYiB,GAAIF,GAE7C,OAAOA,EAIT,SAASH,EAAUR,GAElB,IAAIO,EAAY,IAAIhB,EAAS,KAAMD,EAAKc,MAAO,MAM/C,OAJAU,EAAqBP,GAIdA,EAIR,SAASO,EAAqBZ,GACQ,IAAjCA,EAAKT,iBAAiBa,SAGzBS,QAAQC,IAAId,EAAKV,MACjBU,EAAKT,iBAAiBY,SAAQ,SAAAY,GAC7B,IAAIC,EAAY,YAAOhB,EAAKT,kBACxB0B,EAAQD,EAAaE,WAAU,SAAA5B,GAClC,OAAOA,EAAK6B,OAASJ,EAAMI,QAExB7B,EAAO0B,EAAaI,OAAOH,EAAM,GAAG,GACpCI,EAAU,IAAIhC,EAASC,EAAM0B,EAAchB,GAC/CA,EAAKsB,aAAaD,GAClBT,EAAqBS","file":"static/js/1.9daee161.chunk.js","sourcesContent":["export function coupon(data, withPet = false){\r\n\tclass TreeNode {\r\n\t  constructor(item, possibleChildren, parent=null) {\r\n\t    this.item = item;\r\n\t    this.descendants = [];\r\n\t    this.parent = parent;\r\n\t    this.possibleChildren = possibleChildren\r\n\r\n\t    this.newTotalWeight = null\r\n\t    this.cumulativeRate = null\r\n\t    if(parent && parent.newTotalWeight && parent.cumulativeRate) {\r\n\t    \tthis.newTotalWeight = parent.newTotalWeight - this.item.rate\r\n\t    \tthis.cumulativeRate = (this.item.rate / parent.newTotalWeight) * this.parent.cumulativeRate\r\n\t    } else {\r\n\t    \tif (this.item) {\r\n\t    \t\tthis.newTotalWeight = totalRate - this.item.rate\r\n\t    \t\tthis.cumlativeRate = this.item.rate/totalRate\r\n\t    \t} else {\r\n\t    \t\tthis.newTotalWeight = totalRate\r\n\t    \t\tthis.cumulativeRate = 1\r\n\t    \t}\r\n\t    }\r\n\t\t}\r\n\r\n\t  addDecendant(node){\r\n\t  \tthis.descendants.push(node)\r\n\t  }\t\r\n\t}\r\n\r\n\tlet totalRate = 0;\r\n\tdata.items.forEach((item)=> {\r\n\t\ttotalRate += item.rate\r\n\t})\r\n\t//this if factorial growth and explodes around here\r\n\tif (data.items.length>10){\r\n\t\treturn null\r\n\t}\r\n\tlet startNode = buildTree(totalRate)\r\n\tlet rolls = calculateRolls(startNode, 0)\r\n\treturn rolls\r\n\r\n\tfunction calculateRolls(node, total){\r\n\t\tif (node.descendants.length === 0){\r\n\t\t\treturn total\r\n\t\t} else {\r\n\r\n\t\t\tlet chance = data.chance/100\r\n\t\t\tif (!node.item) {\r\n\t\t\t\ttotal += (1/chance)\r\n\t\t\t} else {\r\n\t\t\t\ttotal += (1/(chance * (node.newTotalWeight/totalRate)))* node.cumulativeRate\r\n\t\t\t}\r\n\r\n\t\t\tfor (let i=0; i<node.descendants.length; i++){\r\n\t\t\t\ttotal = calculateRolls(node.descendants[i], total)\r\n\t\t\t}\r\n\t\t\treturn total\r\n\t\t}\r\n\t}\r\n\r\n\tfunction buildTree(totalRate){\r\n\r\n\t\tlet startNode = new TreeNode(null, data.items, null)\r\n\r\n\t\trecursiveAddChildren(startNode)\r\n\r\n\t\t//recursivePrintTree(startNode, 0)\r\n\r\n\t\treturn startNode;\r\n\r\n\t}\r\n\r\n\tfunction recursiveAddChildren(node){\r\n\t\tif (node.possibleChildren.length === 0){\r\n\t\t\treturn \r\n\t\t} else {\r\n\t\t\tconsole.log(node.item)\r\n\t\t\tnode.possibleChildren.forEach(child => {\r\n\t\t\t\tlet childrenCopy = [...node.possibleChildren]\r\n\t\t\t\tlet index = childrenCopy.findIndex(item => {\r\n\t\t\t\t\treturn item.name === child.name\r\n\t\t\t\t})\r\n\t\t\t\tlet item = childrenCopy.splice(index,1)[0]\r\n\t\t\t\tlet newNode = new TreeNode(item, childrenCopy, node)\r\n\t\t\t\tnode.addDecendant(newNode)\r\n\t\t\t\trecursiveAddChildren(newNode)\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n\tfunction recursivePrintTree(node, index){\r\n\t\tindex += 1\r\n\t\tconsole.log('Tree depth: ' + index)\r\n\t\tconsole.log('Item:' + JSON.stringify(node.item))\r\n\t\tconsole.log('Cumulative rate: ' + node.cumulativeRate, node.newTotalWeight)\r\n\t\tif (node.descendants.length === 0){\r\n\t\t\treturn\r\n\t\t} else {\r\n\t\t\tfor (let i=0; i<node.descendants.length; i++){\r\n\t\t\t\trecursivePrintTree(node.descendants[i], index)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n}\r\n"],"sourceRoot":""}