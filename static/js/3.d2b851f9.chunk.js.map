{"version":3,"sources":["looter/completion-old.js"],"names":["coupon","data","TreeNode","item","possibleChildren","parent","this","descendants","newTotalWeight","cumulativeRate","rate","totalRate","cumlativeRate","node","push","items","forEach","length","startNode","buildTree","rolls","calculateRolls","total","chance","i","recursiveAddChildren","console","log","child","childrenCopy","index","findIndex","name","splice","newNode","addDecendant"],"mappings":"4LAAO,SAASA,EAAOC,GAAuB,IACvCC,EADsC,WAE1C,WAAYC,EAAMC,GAAgC,IAAdC,EAAa,uDAAN,KAAM,oBAC/CC,KAAKH,KAAOA,EACZG,KAAKC,YAAc,GACnBD,KAAKD,OAASA,EACdC,KAAKF,iBAAmBA,EAExBE,KAAKE,eAAiB,KACtBF,KAAKG,eAAiB,KACnBJ,GAAUA,EAAOG,gBAAkBH,EAAOI,gBAC5CH,KAAKE,eAAiBH,EAAOG,eAAiBF,KAAKH,KAAKO,KACxDJ,KAAKG,eAAkBH,KAAKH,KAAKO,KAAOL,EAAOG,eAAkBF,KAAKD,OAAOI,gBAEzEH,KAAKH,MACRG,KAAKE,eAAiBG,EAAYL,KAAKH,KAAKO,KAC5CJ,KAAKM,cAAgBN,KAAKH,KAAKO,KAAKC,IAEpCL,KAAKE,eAAiBG,EACtBL,KAAKG,eAAiB,GAnBgB,gDAwB1C,SAAaI,GACZP,KAAKC,YAAYO,KAAKD,OAzBmB,KA6BxCF,EAAY,EAKhB,GAJAV,EAAKc,MAAMC,SAAQ,SAACb,GACnBQ,GAAaR,EAAKO,QAGfT,EAAKc,MAAME,OAAO,GACrB,OAAO,KAER,IAAIC,EAAYC,EAAUR,GACtBS,EAAQC,EAAeH,EAAW,GACtC,OAAOE,EAEP,SAASC,EAAeR,EAAMS,GAC7B,GAAgC,IAA5BT,EAAKN,YAAYU,OACpB,OAAOK,EAGP,IAAIC,EAAStB,EAAKsB,OAAO,IACpBV,EAAKV,KAGTmB,GAAU,GAAGC,GAAUV,EAAKL,eAAeG,IAAcE,EAAKJ,eAF9Da,GAAU,EAAEC,EAKb,IAAK,IAAIC,EAAE,EAAGA,EAAEX,EAAKN,YAAYU,OAAQO,IACxCF,EAAQD,EAAeR,EAAKN,YAAYiB,GAAIF,GAE7C,OAAOA,EAIT,SAASH,EAAUR,GAElB,IAAIO,EAAY,IAAIhB,EAAS,KAAMD,EAAKc,MAAO,MAM/C,OAJAU,EAAqBP,GAIdA,EAIR,SAASO,EAAqBZ,GACQ,IAAjCA,EAAKT,iBAAiBa,SAGzBS,QAAQC,IAAId,EAAKV,MACjBU,EAAKT,iBAAiBY,SAAQ,SAAAY,GAC7B,IAAIC,EAAY,YAAOhB,EAAKT,kBACxB0B,EAAQD,EAAaE,WAAU,SAAA5B,GAClC,OAAOA,EAAK6B,OAASJ,EAAMI,QAExB7B,EAAO0B,EAAaI,OAAOH,EAAM,GAAG,GACpCI,EAAU,IAAIhC,EAASC,EAAM0B,EAAchB,GAC/CA,EAAKsB,aAAaD,GAClBT,EAAqBS","file":"static/js/3.d2b851f9.chunk.js","sourcesContent":["export function coupon(data, withPet = false){\n\tclass TreeNode {\n\t  constructor(item, possibleChildren, parent=null) {\n\t    this.item = item;\n\t    this.descendants = [];\n\t    this.parent = parent;\n\t    this.possibleChildren = possibleChildren\n\n\t    this.newTotalWeight = null\n\t    this.cumulativeRate = null\n\t    if(parent && parent.newTotalWeight && parent.cumulativeRate) {\n\t    \tthis.newTotalWeight = parent.newTotalWeight - this.item.rate\n\t    \tthis.cumulativeRate = (this.item.rate / parent.newTotalWeight) * this.parent.cumulativeRate\n\t    } else {\n\t    \tif (this.item) {\n\t    \t\tthis.newTotalWeight = totalRate - this.item.rate\n\t    \t\tthis.cumlativeRate = this.item.rate/totalRate\n\t    \t} else {\n\t    \t\tthis.newTotalWeight = totalRate\n\t    \t\tthis.cumulativeRate = 1\n\t    \t}\n\t    }\n\t\t}\n\n\t  addDecendant(node){\n\t  \tthis.descendants.push(node)\n\t  }\t\n\t}\n\n\tlet totalRate = 0;\n\tdata.items.forEach((item)=> {\n\t\ttotalRate += item.rate\n\t})\n\t//this if factorial growth and explodes around here\n\tif (data.items.length>10){\n\t\treturn null\n\t}\n\tlet startNode = buildTree(totalRate)\n\tlet rolls = calculateRolls(startNode, 0)\n\treturn rolls\n\n\tfunction calculateRolls(node, total){\n\t\tif (node.descendants.length === 0){\n\t\t\treturn total\n\t\t} else {\n\n\t\t\tlet chance = data.chance/100\n\t\t\tif (!node.item) {\n\t\t\t\ttotal += (1/chance)\n\t\t\t} else {\n\t\t\t\ttotal += (1/(chance * (node.newTotalWeight/totalRate)))* node.cumulativeRate\n\t\t\t}\n\n\t\t\tfor (let i=0; i<node.descendants.length; i++){\n\t\t\t\ttotal = calculateRolls(node.descendants[i], total)\n\t\t\t}\n\t\t\treturn total\n\t\t}\n\t}\n\n\tfunction buildTree(totalRate){\n\n\t\tlet startNode = new TreeNode(null, data.items, null)\n\n\t\trecursiveAddChildren(startNode)\n\n\t\t//recursivePrintTree(startNode, 0)\n\n\t\treturn startNode;\n\n\t}\n\n\tfunction recursiveAddChildren(node){\n\t\tif (node.possibleChildren.length === 0){\n\t\t\treturn \n\t\t} else {\n\t\t\tconsole.log(node.item)\n\t\t\tnode.possibleChildren.forEach(child => {\n\t\t\t\tlet childrenCopy = [...node.possibleChildren]\n\t\t\t\tlet index = childrenCopy.findIndex(item => {\n\t\t\t\t\treturn item.name === child.name\n\t\t\t\t})\n\t\t\t\tlet item = childrenCopy.splice(index,1)[0]\n\t\t\t\tlet newNode = new TreeNode(item, childrenCopy, node)\n\t\t\t\tnode.addDecendant(newNode)\n\t\t\t\trecursiveAddChildren(newNode)\n\t\t\t})\n\t\t}\n\t}\n\n\t// function recursivePrintTree(node, index){\n\t// \tindex += 1\n\t// \tconsole.log('Tree depth: ' + index)\n\t// \tconsole.log('Item:' + JSON.stringify(node.item))\n\t// \tconsole.log('Cumulative rate: ' + node.cumulativeRate, node.newTotalWeight)\n\t// \tif (node.descendants.length === 0){\n\t// \t\treturn\n\t// \t} else {\n\t// \t\tfor (let i=0; i<node.descendants.length; i++){\n\t// \t\t\trecursivePrintTree(node.descendants[i], index)\n\t// \t\t}\n\t// \t}\n\t// }\n\n}\n"],"sourceRoot":""}